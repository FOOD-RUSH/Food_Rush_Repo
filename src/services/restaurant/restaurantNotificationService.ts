import * as Notifications from 'expo-notifications';\nimport type { Notification } from '@/src/types';\n\n// Restaurant-specific notification types\nexport interface RestaurantNotificationData {\n  type: 'order' | 'business' | 'inventory' | 'promotion' | 'reminder' | 'system';\n  orderId?: string;\n  customerName?: string;\n  orderStatus?: string;\n  itemName?: string;\n  promotionName?: string;\n  revenue?: number;\n  orderCount?: number;\n  priority?: 'low' | 'medium' | 'high';\n  userType: 'restaurant';\n}\n\nexport interface LocalNotificationPayload {\n  title: string;\n  body: string;\n  data?: RestaurantNotificationData;\n  sound?: boolean;\n  badge?: number;\n  categoryId?: string;\n}\n\n/**\n * Restaurant-specific notification service for local notifications\n * Handles business-specific notifications that don't come from the server\n */\nclass RestaurantNotificationService {\n  private static instance: RestaurantNotificationService;\n  private isInitialized = false;\n\n  private constructor() {}\n\n  static getInstance(): RestaurantNotificationService {\n    if (!RestaurantNotificationService.instance) {\n      RestaurantNotificationService.instance = new RestaurantNotificationService();\n    }\n    return RestaurantNotificationService.instance;\n  }\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      // Only set notification categories for restaurant\n      // Don't override the global notification handler as it's already set by the shared service\n      await this.setupNotificationCategories();\n      \n      this.isInitialized = true;\n      console.log('üè™ Restaurant notification service initialized');\n    } catch (error) {\n      console.error('Failed to initialize restaurant notification service:', error);\n    }\n  }\n\n  private async setupNotificationCategories(): Promise<void> {\n    try {\n      // Define notification actions\n      const orderActions: Notifications.NotificationAction[] = [\n        {\n          identifier: 'VIEW_ORDER',\n          buttonTitle: 'View Order',\n          options: { opensAppToForeground: true },\n        },\n        {\n          identifier: 'ACCEPT_ORDER',\n          buttonTitle: 'Accept',\n          options: { opensAppToForeground: true },\n        },\n      ];\n\n      const businessActions: Notifications.NotificationAction[] = [\n        {\n          identifier: 'VIEW_DETAILS',\n          buttonTitle: 'View Details',\n          options: { opensAppToForeground: true },\n        },\n      ];\n\n      const reminderActions: Notifications.NotificationAction[] = [\n        {\n          identifier: 'DISMISS',\n          buttonTitle: 'Dismiss',\n          options: { opensAppToForeground: false },\n        },\n        {\n          identifier: 'SNOOZE',\n          buttonTitle: 'Snooze 15min',\n          options: { opensAppToForeground: false },\n        },\n      ];\n\n      // Set notification categories\n      await Notifications.setNotificationCategoryAsync('ORDER_NOTIFICATION', orderActions);\n      await Notifications.setNotificationCategoryAsync('BUSINESS_NOTIFICATION', businessActions);\n      await Notifications.setNotificationCategoryAsync('REMINDER_NOTIFICATION', reminderActions);\n    } catch (error) {\n      console.error('Failed to setup notification categories:', error);\n    }\n  }\n\n  /**\n   * Send a local notification and add it to the store\n   */\n  private async sendLocalNotification(payload: LocalNotificationPayload): Promise<string> {\n    try {\n      const notificationId = await Notifications.scheduleNotificationAsync({\n        content: {\n          title: payload.title,\n          body: payload.body,\n          data: payload.data || {},\n          sound: payload.sound !== false,\n          badge: payload.badge,\n          categoryIdentifier: payload.categoryId,\n        },\n        trigger: null, // Send immediately\n      });\n\n      // Add to notification store as a local notification\n      const notification: Notification = {\n        id: notificationId,\n        title: payload.title,\n        body: payload.body,\n        type: payload.data?.type || 'system',\n        priority: payload.data?.priority || 'medium',\n        data: payload.data,\n        readAt: null,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n      };\n\n      // Add to store using dynamic import to avoid circular dependencies\n      try {\n        const { useNotificationStore } = await import('@/src/stores/shared/notificationStore');\n        const { addNotification } = useNotificationStore.getState();\n        addNotification(notification);\n      } catch (error) {\n        console.warn('Could not add notification to store:', error);\n      }\n\n      return notificationId;\n    } catch (error) {\n      console.error('Failed to send local notification:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Schedule a notification for later\n   */\n  private async scheduleNotification(\n    payload: LocalNotificationPayload,\n    trigger: Notifications.NotificationTriggerInput\n  ): Promise<string> {\n    try {\n      const notificationId = await Notifications.scheduleNotificationAsync({\n        content: {\n          title: payload.title,\n          body: payload.body,\n          data: payload.data || {},\n          sound: payload.sound !== false,\n          badge: payload.badge,\n          categoryIdentifier: payload.categoryId,\n        },\n        trigger,\n      });\n\n      return notificationId;\n    } catch (error) {\n      console.error('Failed to schedule notification:', error);\n      throw error;\n    }\n  }\n\n  // === ORDER NOTIFICATIONS ===\n\n  async notifyNewOrder(\n    orderId: string,\n    customerName: string,\n    orderTotal: number\n  ): Promise<string> {\n    return this.sendLocalNotification({\n      title: 'üîî New Order Received!',\n      body: `Order from ${customerName} - $${orderTotal.toFixed(2)}`,\n      data: {\n        type: 'order',\n        orderId,\n        customerName,\n        orderStatus: 'pending',\n        priority: 'high',\n        userType: 'restaurant',\n      },\n      categoryId: 'ORDER_NOTIFICATION',\n      sound: true,\n    });\n  }\n\n  async notifyOrderTimeout(orderId: string, customerName: string): Promise<string> {\n    return this.sendLocalNotification({\n      title: '‚è∞ Order Timeout Warning',\n      body: `Order ${orderId} from ${customerName} needs attention`,\n      data: {\n        type: 'order',\n        orderId,\n        customerName,\n        priority: 'high',\n        userType: 'restaurant',\n      },\n      categoryId: 'ORDER_NOTIFICATION',\n      sound: true,\n    });\n  }\n\n  // === BUSINESS NOTIFICATIONS ===\n\n  async notifyDailySummary(\n    totalOrders: number,\n    totalRevenue: number,\n    date: string\n  ): Promise<string> {\n    return this.sendLocalNotification({\n      title: 'üìä Daily Summary',\n      body: `${date}: ${totalOrders} orders, $${totalRevenue.toFixed(2)} revenue`,\n      data: {\n        type: 'business',\n        orderCount: totalOrders,\n        revenue: totalRevenue,\n        priority: 'medium',\n        userType: 'restaurant',\n      },\n      categoryId: 'BUSINESS_NOTIFICATION',\n    });\n  }\n\n  async notifyPeakHours(expectedOrders: number): Promise<string> {\n    return this.sendLocalNotification({\n      title: 'üî• Peak Hours Starting',\n      body: `Expecting ${expectedOrders} orders in the next hour. Get ready!`,\n      data: {\n        type: 'business',\n        orderCount: expectedOrders,\n        priority: 'medium',\n        userType: 'restaurant',\n      },\n      categoryId: 'BUSINESS_NOTIFICATION',\n    });\n  }\n\n  async notifySlowPeriod(): Promise<string> {\n    return this.sendLocalNotification({\n      title: 'üìâ Slow Period Detected',\n      body: 'Consider running a promotion to boost orders',\n      data: {\n        type: 'business',\n        priority: 'low',\n        userType: 'restaurant',\n      },\n      categoryId: 'BUSINESS_NOTIFICATION',\n    });\n  }\n\n  // === INVENTORY NOTIFICATIONS ===\n\n  async notifyLowStock(itemName: string, currentStock: number): Promise<string> {\n    return this.sendLocalNotification({\n      title: '‚ö†Ô∏è Low Stock Alert',\n      body: `${itemName} is running low (${currentStock} remaining)`,\n      data: {\n        type: 'inventory',\n        itemName,\n        priority: 'medium',\n        userType: 'restaurant',\n      },\n      categoryId: 'BUSINESS_NOTIFICATION',\n    });\n  }\n\n  async notifyOutOfStock(itemName: string): Promise<string> {\n    return this.sendLocalNotification({\n      title: 'üö´ Out of Stock',\n      body: `${itemName} is out of stock. Update your menu.`,\n      data: {\n        type: 'inventory',\n        itemName,\n        priority: 'high',\n        userType: 'restaurant',\n      },\n      categoryId: 'BUSINESS_NOTIFICATION',\n      sound: true,\n    });\n  }\n\n  // === PROMOTION NOTIFICATIONS ===\n\n  async notifyPromotionPerformance(\n    promotionName: string,\n    ordersGenerated: number\n  ): Promise<string> {\n    return this.sendLocalNotification({\n      title: 'üéØ Promotion Update',\n      body: `\"${promotionName}\" generated ${ordersGenerated} orders today!`,\n      data: {\n        type: 'promotion',\n        promotionName,\n        orderCount: ordersGenerated,\n        priority: 'low',\n        userType: 'restaurant',\n      },\n      categoryId: 'BUSINESS_NOTIFICATION',\n    });\n  }\n\n  // === REMINDER NOTIFICATIONS ===\n\n  async scheduleMenuUpdateReminder(hours: number = 24): Promise<string> {\n    const trigger: Notifications.TimeIntervalNotificationTrigger = {\n      seconds: hours * 60 * 60,\n    };\n\n    return this.scheduleNotification(\n      {\n        title: 'üìù Menu Update Reminder',\n        body: 'Remember to update your menu and check item availability',\n        data: {\n          type: 'reminder',\n          priority: 'medium',\n          userType: 'restaurant',\n        },\n        categoryId: 'REMINDER_NOTIFICATION',\n      },\n      trigger\n    );\n  }\n\n  async scheduleBusinessHoursReminder(minutesBeforeClose: number = 30): Promise<string> {\n    const trigger: Notifications.TimeIntervalNotificationTrigger = {\n      seconds: minutesBeforeClose * 60,\n    };\n\n    return this.scheduleNotification(\n      {\n        title: 'üïê Closing Time Approaching',\n        body: `Your restaurant closes in ${minutesBeforeClose} minutes`,\n        data: {\n          type: 'reminder',\n          priority: 'medium',\n          userType: 'restaurant',\n        },\n        categoryId: 'REMINDER_NOTIFICATION',\n      },\n      trigger\n    );\n  }\n\n  async scheduleOrderCheckReminder(minutes: number = 15): Promise<string> {\n    const trigger: Notifications.TimeIntervalNotificationTrigger = {\n      seconds: minutes * 60,\n    };\n\n    return this.scheduleNotification(\n      {\n        title: 'üëÄ Check Pending Orders',\n        body: 'You have orders that may need attention',\n        data: {\n          type: 'reminder',\n          priority: 'medium',\n          userType: 'restaurant',\n        },\n        categoryId: 'REMINDER_NOTIFICATION',\n      },\n      trigger\n    );\n  }\n\n  // === SYSTEM NOTIFICATIONS ===\n\n  async notifyAppUpdate(version: string): Promise<string> {\n    return this.sendLocalNotification({\n      title: 'üîÑ App Update Available',\n      body: `Version ${version} is available with new features`,\n      data: {\n        type: 'system',\n        priority: 'low',\n        userType: 'restaurant',\n      },\n      categoryId: 'BUSINESS_NOTIFICATION',\n    });\n  }\n\n  async notifyMaintenanceMode(startTime: string, duration: string): Promise<string> {\n    return this.sendLocalNotification({\n      title: 'üîß Scheduled Maintenance',\n      body: `System maintenance at ${startTime} for ${duration}`,\n      data: {\n        type: 'system',\n        priority: 'medium',\n        userType: 'restaurant',\n      },\n      categoryId: 'BUSINESS_NOTIFICATION',\n    });\n  }\n\n  // === UTILITY METHODS ===\n\n  /**\n   * Cancel specific notification\n   */\n  async cancelNotification(notificationId: string): Promise<void> {\n    try {\n      await Notifications.cancelScheduledNotificationAsync(notificationId);\n    } catch (error) {\n      console.error('Failed to cancel notification:', error);\n    }\n  }\n\n  /**\n   * Cancel all scheduled notifications\n   */\n  async cancelAllNotifications(): Promise<void> {\n    try {\n      await Notifications.cancelAllScheduledNotificationsAsync();\n    } catch (error) {\n      console.error('Failed to cancel all notifications:', error);\n    }\n  }\n\n  /**\n   * Get all scheduled notifications\n   */\n  async getScheduledNotifications(): Promise<Notifications.NotificationRequest[]> {\n    try {\n      return await Notifications.getAllScheduledNotificationsAsync();\n    } catch (error) {\n      console.error('Failed to get scheduled notifications:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Clear notification badge\n   */\n  async clearBadge(): Promise<void> {\n    try {\n      await Notifications.setBadgeCountAsync(0);\n    } catch (error) {\n      console.error('Failed to clear badge:', error);\n    }\n  }\n\n  /**\n   * Set notification badge count\n   */\n  async setBadgeCount(count: number): Promise<void> {\n    try {\n      await Notifications.setBadgeCountAsync(count);\n    } catch (error) {\n      console.error('Failed to set badge count:', error);\n    }\n  }\n\n  /**\n   * Check if notifications are enabled\n   */\n  async areNotificationsEnabled(): Promise<boolean> {\n    try {\n      const settings = await Notifications.getPermissionsAsync();\n      return settings.status === 'granted';\n    } catch (error) {\n      console.error('Failed to check notification permissions:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Request notification permissions\n   */\n  async requestPermissions(): Promise<boolean> {\n    try {\n      const { status } = await Notifications.requestPermissionsAsync({\n        ios: {\n          allowAlert: true,\n          allowBadge: true,\n          allowSound: true,\n          allowAnnouncements: true,\n        },\n      });\n      return status === 'granted';\n    } catch (error) {\n      console.error('Failed to request notification permissions:', error);\n      return false;\n    }\n  }\n}\n\n// Export singleton instance\nexport const restaurantNotificationService = RestaurantNotificationService.getInstance();\nexport default RestaurantNotificationService;\n"